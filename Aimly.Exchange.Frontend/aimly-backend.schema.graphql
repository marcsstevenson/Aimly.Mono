"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """Deferred when true."""
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int! = 0

  """Streamed when true."""
  if: Boolean
) on FIELD

"""
The `@specifiedBy` directive is used within the type system definition language
to provide a URL for specifying the behavior of custom scalar definitions.
"""
directive @specifiedBy(
  """
  The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types.
  """
  url: String!
) on SCALAR

"""Adds a note to an existing company"""
input AddNoteToCompanyCommandInput {
  tenantId: UUID!

  """The Id of the company to add the note to"""
  companyId: UUID!

  """The parent note if any. Notes with a parent are considered a comment."""
  parentNoteId: UUID

  """If the note is to be sticky"""
  sticky: Boolean

  """The type of the alert, if any."""
  alertType: AlertType

  """The body of the note. This is HTML."""
  body: String!
}

enum AlertType {
  PRIMARY
  SECONDARY
  SUCCESS
  DANGER
  WARNING
  INFO
  LIGHT
  DARK
}

"""
Encapsulates the Auth profile that is obtained when a user logs into an OAuth provider
"""
input AuthProfileInput {
  given_name: String
  family_name: String
  nickname: String
  name: String
  picture: String
  locale: String
  updated_at: DateTime
  email: String
  email_verified: Boolean
  sub: String
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

type DeleteProfileResponse {
  deletedProfileId: UUID!
}

type ExperienceModel {
  id: UUID
  description: String
  title: String
  organisation: String
  startMonth: Int!
  startYear: Int!
  endMonth: Int
  endYear: Int
}

input ExperienceModelInput {
  id: UUID
  description: String
  title: String
  organisation: String
  startMonth: Int!
  startYear: Int!
  endMonth: Int
  endYear: Int
}

input GetAboutYouCommandInput {
  userId: UUID!
  companyProfileId: UUID
}

type GetAboutYouModel {
  userId: UUID
  language: String
  personalProfilePictureUrl: String
  about: String
  timezone: String
  givenName: String
  familyName: String
  phoneNumber: String
  linkedInProfile: String
  companyProfileId: UUID
  companyProfilePictureUrl: String
  companyName: String
  website: String
  numberOfFounders: Int
  industries: [String]
  floor: String
  streetNumber: String
  streetName: String
  addressLocality: String
  addressCity: String
  addressRegion: String
  addressCountry: String
  postalCode: String
  postOfficeBoxNumber: String
}

input GetAboutYouModelInput {
  userId: UUID
  language: String
  personalProfilePictureUrl: String
  about: String
  timezone: String
  givenName: String
  familyName: String
  phoneNumber: String
  linkedInProfile: String
  companyProfileId: UUID
  companyProfilePictureUrl: String
  companyName: String
  website: String
  numberOfFounders: Int
  industries: [String]
  floor: String
  streetNumber: String
  streetName: String
  addressLocality: String
  addressCity: String
  addressRegion: String
  addressCountry: String
  postalCode: String
  postOfficeBoxNumber: String
}

type GetAccessResponse {
  exceptionMessage: String
  endpointUrl: String
  identityId: String
  token: String
  expiresOn: DateTime!
}

input GetAccessToMeetingCommandInput {
  userId: UUID!
}

type GetExpertProfileModel {
  userId: UUID!
  id: UUID
  name: String!
  about: String!
  listOnMarket: Boolean!
  industries: [String]
  skills: [String]
}

input GetExpertProfileModelInput {
  userId: UUID!
  id: UUID
  name: String!
  about: String!
  listOnMarket: Boolean!
  industries: [String]
  skills: [String]
}

type GetMentorProfileModel {
  userId: UUID!
  id: UUID
  name: String!
  about: String!
  listOnMarket: Boolean!
  industries: [String]
  skills: [String]
}

input GetMentorProfileModelInput {
  userId: UUID!
  id: UUID
  name: String!
  about: String!
  listOnMarket: Boolean!
  industries: [String]
  skills: [String]
}

type GetPersonalProfileModel {
  userId: UUID
  language: String
  personalProfilePictureUrl: String
  about: String
  timezone: String
  givenName: String
  familyName: String
  phoneNumber: String
  linkedInProfile: String
  industries: [String]
  skills: [String]
  employmentExperience: [ExperienceModel]
}

input GetPersonalProfileModelInput {
  userId: UUID
  language: String
  personalProfilePictureUrl: String
  about: String
  timezone: String
  givenName: String
  familyName: String
  phoneNumber: String
  linkedInProfile: String
  industries: [String]
  skills: [String]
  employmentExperience: [ExperienceModelInput]
}

input GetPotentialCommandInput {
  userId: UUID!
  companyProfileId: UUID!
}

type GetPotentialModel {
  userId: UUID!
  companyProfileId: UUID!
  value: String
  potentialSize: String
  potentialValue: String
}

input GetPotentialModelInput {
  userId: UUID!
  companyProfileId: UUID!
  value: String
  potentialSize: String
  potentialValue: String
}

input GetTheProblemCommandInput {
  userId: UUID!
  companyProfileId: UUID!
}

type GetTheProblemModel {
  userId: UUID!
  companyProfileId: UUID!
  purposeDetails: String
  problemDetails: String
}

input GetTheProblemModelInput {
  userId: UUID!
  companyProfileId: UUID!
  purposeDetails: String
  problemDetails: String
}

input GetTheSolutionCommandInput {
  userId: UUID!
  companyProfileId: UUID!
}

type GetTheSolutionModel {
  userId: UUID!
  companyProfileId: UUID!
  solutionNovelty: String
  solutionDescription: String
  stateOfValidation: String
  competition: String
  positionVsCompetition: String
  businessModel: String
  traction: String
  founders: String
  currentAnnualRevenue: String
  externalFunding: String
}

input GetTheSolutionModelInput {
  userId: UUID!
  companyProfileId: UUID!
  solutionNovelty: String
  solutionDescription: String
  stateOfValidation: String
  competition: String
  positionVsCompetition: String
  businessModel: String
  traction: String
  founders: String
  currentAnnualRevenue: String
  externalFunding: String
}

input MarketSearchCommandInput {
  profileType: ProfileTypeOption!
  searchTerm: String
  pageSize: Int!
  currentPage: Int!
  orderBy: String
  orderByAscending: Boolean!
}

type MarketSearchResult {
  id: UUID!
  profileId: UUID!
  name: String
  description: String
  profileUrl: String
  type: ProfileTypeOption!
}

type MarketSearchResults {
  results: [MarketSearchResult]
  totalResultCount: Int!
  currentPage: Int!
  totalPageCount: Int!
}

type Mutation {
  """
  Takes an auth profile model and either creates a user if unknown or updates a
  user if already known. The Id of the user is then returned.
  """
  checkIn(input: AuthProfileInput): UUID!
  addNoteToCompany(input: AddNoteToCompanyCommandInput): UUID
  accessToMeeting(input: GetAccessToMeetingCommandInput): GetAccessResponse
  setPersonalProfile(input: SetPersonalProfileCommandInput): SetPersonalProfileResponse
  deleteMentorProfile(userId: UUID!, profileId: UUID!): DeleteProfileResponse
  setMentorProfile(input: SetMentorProfileCommandInput): SetMentorProfileResponse
  setTheSolution(input: SetTheSolutionCommandInput): SetTheSolutionResponse
  setTheProblem(input: SetTheProblemCommandInput): SetTheProblemResponse
  setPotential(input: SetPotentialCommandInput): SetPotentialResponse
  deleteCompanyProfile(userId: UUID!, profileId: UUID!): DeleteProfileResponse
  setAboutYou(input: SetAboutYouCommandInput): SetAboutYouResponse
  deleteExpertProfile(userId: UUID!, profileId: UUID!): DeleteProfileResponse
  setExpertProfile(input: SetExpertProfileCommandInput): SetExpertProfileResponse
  setExperienceDetailed(userId: UUID!, experienceDetailedModel: ExperienceModelInput): SetExperienceDetailedResponse
}

type MyProfilesResult {
  id: UUID!
  profileId: UUID!
  name: String
  type: ProfileTypeOption!
}

type NoteSearchResultModel {
  body: String
  createdByUserName: String
  lastEditedByUserName: String
  comments: [NoteSearchResultModel]
}

input NotesForCompanyCommandInput {
  tenantId: UUID!
  companyId: UUID!
  afterDateTime: DateTime!
}

input ProfileSearchCommandInput {
  userId: UUID!
  typesFilter: [ProfileTypeOption!]
}

type ProfileSearchResult {
  id: UUID!
  name: String
  profilePictureUrl: String
  language: String
  description: String
  type: ProfileTypeOption!
}

enum ProfileTypeOption {
  PERSONAL
  STARTUP
  MENTOR
  EXPERT
}

type Query {
  userSearch(command: UserSearchCommandInput): [UserSearchResult]
  notesForCompany(command: NotesForCompanyCommandInput): [NoteSearchResultModel]
  profileSearch(command: ProfileSearchCommandInput): [ProfileSearchResult]
  getPersonalProfile(userId: UUID!): GetPersonalProfileModel
  myProfiles(userId: UUID!): [MyProfilesResult]
  getMentorProfile(userId: UUID!, id: UUID!): GetMentorProfileModel
  getSkillOptions(nameStartingWith: String): [String]
  marketSearch(marketSearchCommand: MarketSearchCommandInput): MarketSearchResults
  getTheSolution(command: GetTheSolutionCommandInput): GetTheSolutionModel
  getTheProblem(command: GetTheProblemCommandInput): GetTheProblemModel
  getPotential(command: GetPotentialCommandInput): GetPotentialModel
  getAboutYou(command: GetAboutYouCommandInput): GetAboutYouModel
  getExpertProfile(userId: UUID!, id: UUID!): GetExpertProfileModel
}

input SetAboutYouCommandInput {
  getAboutYouModel: GetAboutYouModelInput
}

type SetAboutYouResponse {
  updatedPersonalProfileId: UUID!
  updatedCompanyProfileId: UUID!
}

type SetExperienceDetailedResponse {
  updatedExperienceId: UUID!
}

input SetExpertProfileCommandInput {
  getExpertProfileModel: GetExpertProfileModelInput
}

type SetExpertProfileResponse {
  updatedExpertProfileId: UUID!
}

input SetMentorProfileCommandInput {
  getMentorProfileModel: GetMentorProfileModelInput
}

type SetMentorProfileResponse {
  updatedMentorProfileId: UUID!
}

input SetPersonalProfileCommandInput {
  getPersonalProfileModel: GetPersonalProfileModelInput
}

type SetPersonalProfileResponse {
  updatedPersonalProfileId: UUID!
}

input SetPotentialCommandInput {
  getPotentialModel: GetPotentialModelInput
}

type SetPotentialResponse {
  updatedCompanyProfileId: UUID!
}

input SetTheProblemCommandInput {
  getTheProblemModel: GetTheProblemModelInput
}

type SetTheProblemResponse {
  updatedCompanyProfileId: UUID!
}

input SetTheSolutionCommandInput {
  getTheSolutionModel: GetTheSolutionModelInput
}

type SetTheSolutionResponse {
  updatedCompanyProfileId: UUID!
}

input UserSearchCommandInput {
  fullNameContains: String
}

type UserSearchResult {
  """The user's Id"""
  id: UUID!

  """The associated user's full name"""
  fullName: String

  """The URL of the user's profile image"""
  pictureUrl: String
}

scalar UUID

